[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TinderGames",
    "section": "",
    "text": "Welcome to the documentation web for our school project on “Matching Table Games between Users and a Library of Table Games.\nThis platform will have a comprehensive library of table games, with information on each game’s rules, objectives, and recommended number of players. Users can browse through the library, learn about new games, and even suggest new games to be added.\nOur user, can register his owned games and see stadistic of his plays, in order to check his collection games and his playings of this games. Also, this site will provide a tool to create appointments between users to play together with their games. – Aqui link de los avances practicos de la web. –\nOur team will follow the SCRUM methodology to create this project. So, our team is committed to delivering a high-quality product that meets the needs of our users. We believe with its focus on collaboration, adaptability, and continuous improvement, is the ideal methodology to help us achieve this goal. – Aqui link de la estructura SCRUM. –\nThis documentation web .qmd is designed to keep everyone informed about the project’s progress and to ensure that everyone is on the same page. It will include information on our sprints, user stories, and any important updates or changes to the project. – Aqui link de sprints, user stories, etc.–\nThank you for taking the time to read this introduction, and we look forward to sharing our progress with you."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About us",
    "section": "",
    "text": "We’re a group of students of the CIFO Web applications course with very diverse backgrounds:\n\nVíctor Calvache:\nDavid Maqueda:\nMarc Palacín: Industrial engineer with a passion for computer science, I’ve been a software engineer for more than 6 years and now I’m gearing towards the DevOps world"
  },
  {
    "objectID": "design/functional-diagrams.html",
    "href": "design/functional-diagrams.html",
    "title": "Functional diagrams",
    "section": "",
    "text": "This diagrams shows the workflow of our app based on what the user can do based on the use-cases of our service.\n\n\n\nThis is the use-case diagram when a user wants to register for the service\n\n\n\n\n\n\nCreating a new user\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\n\nDiagram for user’s login use-case\n\n\n\n\n\n\nUser login\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\n\nThis use-case is only for administration tasks. Only Admin can register new boardgames to the data base.\n\n\n\n\n\n\nCreating a Board Game\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\n\nUse-case diagram for searching a Board Game from the data base\n\n\n\n\n\n\nSearching a Board Game\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\n\nThis use-case is based on the steps a user should take to publish a game to be played with friends.\n\n\n\n\n\n\nCreating a Board Game Session\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "design/functional-diagrams.html#user-registration",
    "href": "design/functional-diagrams.html#user-registration",
    "title": "Functional diagrams",
    "section": "",
    "text": "This is the use-case diagram when a user wants to register for the service\n\n\n\n\n\n\nCreating a new user\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "design/functional-diagrams.html#user-login",
    "href": "design/functional-diagrams.html#user-login",
    "title": "Functional diagrams",
    "section": "",
    "text": "Diagram for user’s login use-case\n\n\n\n\n\n\nUser login\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "design/functional-diagrams.html#creating-board-games",
    "href": "design/functional-diagrams.html#creating-board-games",
    "title": "Functional diagrams",
    "section": "",
    "text": "This use-case is only for administration tasks. Only Admin can register new boardgames to the data base.\n\n\n\n\n\n\nCreating a Board Game\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "design/functional-diagrams.html#searching-a-boardgame",
    "href": "design/functional-diagrams.html#searching-a-boardgame",
    "title": "Functional diagrams",
    "section": "",
    "text": "Use-case diagram for searching a Board Game from the data base\n\n\n\n\n\n\nSearching a Board Game\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "design/functional-diagrams.html#creating-a-game-session",
    "href": "design/functional-diagrams.html#creating-a-game-session",
    "title": "Functional diagrams",
    "section": "",
    "text": "This use-case is based on the steps a user should take to publish a game to be played with friends.\n\n\n\n\n\n\nCreating a Board Game Session\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "backend/controllers.html",
    "href": "backend/controllers.html",
    "title": "Controller",
    "section": "",
    "text": "This section covers all the controllers developed for performing CRUD operations of our service from the server side. This tasks will be performed only by Administrators, not users.\n\n\nUser Controller and server endpoints implementation.\nUser has a login sesion implementation.\npackage org.teamcifo.tindergames.userEntity;\n\nimport jakarta.servlet.http.HttpSession;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport java.util.*;\n\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    private String IS_LOGGED_IN = \"isLoggedIn\";\n    private static final String RESPONSE_MESSAGE = \"responseMessage\";\n    @Autowired\n    UserService userService;\n\n    private final Set&lt;String&gt; sessionIds = Collections.synchronizedSet(new HashSet&lt;&gt;());\n\n    // Index page\n    /**\n     * Users controller main page\n     * @param containerToView contains relevant data to correctly render Thymeleaf view\n     * @return the main page HTML file\n     */\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"usersFromController\", userService.getAllUsers());\n        return \"users/index\";\n    }\n\n    // CRUD operations\n    // - Create a new user:\n    /**\n     * User's creation GET method. It initializes a new user so it can be populated\n     * @param containerToView contains the new empty User\n     * @return the user's creation form HTML file\n     */\n    @GetMapping(value = {\"/createUser\", \"/createUser/\"})\n    public String createUser(Model containerToView) {\n        containerToView.addAttribute(\"user\", new User());\n        containerToView.addAttribute(\"operation\", \"createUser\");\n        return \"users/userForm\";\n    }\n\n    /**\n     * User's creation POST method. If the newUser ID doesn't exist, the newUser object is stored in the DB\n     * @param id is the ID of the new User (obsolete)\n     * @param newUser is the new User object\n     * @param redirectAttributes contains the response message to be rendered in the GET method when finished\n     * @return a redirect to the GET method\n     */\n    @PostMapping(value = \"/createUser/{id}\")\n    public String createUser(@PathVariable(\"id\") String id, Optional&lt;User&gt; newUser, RedirectAttributes redirectAttributes) {\n        // Check that the ID is not already used inside the DB\n        if (newUser.isPresent() && userService.getUserByID(newUser.get().getUserId()) == null) {\n            userService.addUserToDB(newUser.get());\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + newUser.get().getUsername() + \" saved\");\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Received object doesn't contain a user or User ID \" + newUser.get().getUserId() + \" already in DB!\");\n        }\n        return \"redirect:/users/createUser\";\n    }\n\n    // - Read an existing user by ID\n    /**\n     * Retrieve the User object based on the provided ID\n     * @param id is the ID of the desired User\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(value = \"/id/{id}\")\n    public String getUserByID(@PathVariable(\"id\") String id, Model containerToView) {\n        User userFromDB = userService.getUserByID(id);\n        containerToView.addAttribute(\"user\", userFromDB);\n        if (userFromDB != null) {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" found\");\n        } else {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n        }\n        return \"users/userDetails\";\n    }\n\n    // - Read an existing user by username\n    /**\n     * Retrieve the User object based on the provided username\n     * @param username is the username of the desired User\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(value = \"/username/{username}\")\n    public String getUserByUsername(@PathVariable(\"username\") String username, Model containerToView) {\n        User userFromDB = userService.getUserByUsername(username);\n        containerToView.addAttribute(\"user\", userFromDB);\n        if (userFromDB != null) {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"Username \" + username + \" found\");\n        } else {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"Username \" + username + \" not found!\");\n        }\n        return \"users/userDetails\";\n    }\n\n    // - Update an existing user by ID\n    /**\n     * User's update GET method. Based on the provided ID, if the user exists, it will be retrieved and presented in a\n     * form for further modification.\n     * @param id is the user-to-update ID\n     * @param containerToView contains the User object that matches the given ID\n     * @param redirectAttributes contains the response message of the operation\n     * @return the path to the User update form if the user exists, or a redirect to the User's main page otherwise\n     */\n    @GetMapping(value = \"/updateUser/{id}\")\n    public String updateUser(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userFromDB = userService.getUserByID(id);\n        if (userFromDB != null) {\n            // Store the user object and go to the update form\n            containerToView.addAttribute(\"user\", userFromDB);\n            containerToView.addAttribute(\"operation\", \"updateUser\");\n            return \"users/userForm\";\n        } else {\n            // Redirect the user to the main page\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n            return \"redirect:/users/\";\n        }\n    }\n\n    /**\n     * User's update POST method. Based on the provided ID, if the user exists into the DB, it is replaced\n     * with the updated one\n     * @param id is the ID of the user to update\n     * @param updatedUser is the User object with the updated values\n     * @param redirectAttr contains the response message\n     * @return the path to the GET method\n     */\n    @PostMapping(value = \"/updateUser/{id}\")\n    public String updateUser(@PathVariable(\"id\") String id, Optional&lt;User&gt; updatedUser, RedirectAttributes redirectAttr) {\n        // Retrieve the user based on the provided ID\n        User userToUpdate = userService.getUserByID(id);\n        if (updatedUser.isPresent()) {\n            // Check if the User already exists and the IDs are equal\n            if (userToUpdate != null && updatedUser.get().getUserId().equals(userToUpdate.getUserId())) {\n                // Update the user\n                userService.updateUserInDB(updatedUser.get());\n                // Return response message\n                redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + updatedUser.get().getUsername() + \" updated\");\n            } else {\n                // Something wrong with the ID or the Database\n                redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"UserID \" + id + \" not found or doesn't match the DB\");\n            }\n        } else {\n            // Something wrong with the updated object\n            redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"Received object doesn't contain a user!\");\n        }\n        // Redirect to the GET method\n        return \"redirect:/users/updateUser/\" + id;\n    }\n\n    /**\n     * User's deletion method based on its ID. If the ID exists, the user is removed from the DB\n     * @param id is the ID of the user to delete\n     * @param redirectAttributes include the response message of the operation\n     * @return redirects to the user's main page to show the updated list of users\n     */\n    @GetMapping(\"/deleteUser/{id}\")\n    public String deleteUser(@PathVariable(\"id\") String id, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userToDelete = userService.getUserByID(id);\n        if (userService.deleteUserFromDB(userToDelete)) {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + userToDelete.getUsername() + \" deleted\");\n        }\n        else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + userToDelete.getUsername() + \" couldn't be deleted!\");\n        }\n        // Return to the users main page\n        return \"redirect:/users/\";\n    }\n\n    // Log In endpoint\n    @GetMapping(\"login\")\n    public String logIn(HttpSession session, Model containerToView) {\n        session.setAttribute(IS_LOGGED_IN, false);\n        return \"users/userLogin\";\n    }\n\n    @PostMapping(\"login\")\n    public String logIn(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password, HttpSession session, RedirectAttributes redirectAttributes) {\n        // Check if the username and passwords are correct\n        User loggedUser = userService.logIn(username, password);\n        if (loggedUser != null && !this.sessionIds.contains(session.getId())) {\n            // Add the HTTP session id to the sessions set\n            this.sessionIds.add(session.getId());\n            // Set the login value to true\n            session.setAttribute(IS_LOGGED_IN, true);\n            // Save useful user attributes in the HTTP session\n            session.setAttribute(\"userId\", loggedUser.getUserId());\n            session.setAttribute(\"username\", loggedUser.getUsername());\n            // Return to the index page\n            return \"index\";\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Username or password incorrect\");\n            // Redirect to the login page\n            return \"redirect:/users/login\";\n        }\n\n    }\n\n    @GetMapping(\"/logout\")\n    public String logout(HttpSession session) {\n        // Restart the session attributes\n        session.removeAttribute(IS_LOGGED_IN);\n        session.removeAttribute(\"userId\");\n        session.removeAttribute(\"username\");\n        // Remove the current session from the sessions set\n        this.sessionIds.remove(session.getId());\n        // Return to the main page and force the login again\n        return \"redirect:/\";\n    }\n\n    // Other user operations\n    @GetMapping(\"resetPassword/{id}\")\n    public String resetPassword(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userFromDB = userService.getUserByID(id);\n        if (userFromDB != null) {\n            containerToView.addAttribute(\"userId\", id);\n            containerToView.addAttribute(\"oldPassword\", userFromDB.getPassword());\n            return \"users/resetPassword\";\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n            return \"redirect:/users\";\n        }\n    }\n\n    @PostMapping(\"resetPassword/{id}\")\n    public String resetPassword(@PathVariable(\"id\") String id, @RequestParam(\"newPassword\") String newPassword, RedirectAttributes redirectAttributes) {\n        // Try to update the user's password\n        if (userService.updateUserPassword(id, newPassword)) {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Password for user ID \" + id + \" updated\");\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n        }\n        return \"redirect:/users\";\n    }\n\n    // Add friends to the User's profile\n    @GetMapping(\"addFriends/{id}\")\n    public String addFriends(@PathVariable(\"id\") String userId, HttpSession session, Model containerToView, RedirectAttributes redirectAttributes) {\n        if ((boolean) session.getAttribute(IS_LOGGED_IN) && userId.equals(session.getAttribute(\"userId\"))) {\n            if (userService.getUserByID(userId) != null) {\n                // Include both the current friend's list, the user ID and the list of available users to the frontend\n                containerToView.addAttribute(\"currentFriends\", userService.getUserFriends(userId));\n                containerToView.addAttribute(\"availableFriends\", userService.getAllUsers());\n                // TODO: remove userId from Model as it should be already available in the HttpSession --&gt; Modify frontend accordingly\n                containerToView.addAttribute(\"userId\", userId);\n                containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + userId + \" found\");\n                return \"users/friendsForm\";\n            } else {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in! Cancelling friend's update\");\n                return \"redirect:/users/id\" + userId;\n            }\n        }\n        redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in! Cancelling friend's update\");\n        return \"redirect:/users/id\" + userId;\n    }\n\n    @PostMapping(\"addFriends/{id}\")\n    public String addFriend(@PathVariable(\"id\") String userId, @RequestParam(\"friendsIds\") List&lt;String&gt; friendsIds, HttpSession session, RedirectAttributes redirectAttributes) {\n        // Only add friends if the user is logged in and the ID received is the same as the one from the current session\n        if ((boolean) session.getAttribute(IS_LOGGED_IN) && userId.equals(session.getAttribute(\"userId\"))) {\n            if (userService.addFriends(userId, friendsIds)) {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Friends added to user's profile!\");\n            } else {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not found in DB, friend's update cancelled\");\n            }\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in, friend's update cancelled\");\n        }\n        return \"redirect:/users/id/\" + userId;\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server User templates\n\n\n\nBoardGame Controller and server endpoints implementation\npackage org.teamcifo.tindergames.boardGameEntity;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\nimport org.teamcifo.tindergames.userEntity.User;\n\nimport java.util.ArrayList;\nimport java.util.Optional;\n\n@Controller\n@RequestMapping(\"/boardgames\")\npublic class BoardGameController {\n    @Autowired\n    BoardGameService boardGameService;\n\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"boardGamesFromController\", boardGameService.getAllBoardGames());\n        return \"boardgames/index\";\n    }\n\n    @GetMapping(value = {\"/creategame\", \"/creategame/\"})\n    public String createBoardGame(Model containerToView) {\n        containerToView.addAttribute(\"boardgame\", new BoardGame());\n        containerToView.addAttribute(\"operation\", \"creategame\");\n        return \"boardgames/creategame.html\";\n    }\n\n    @PostMapping(value = \"/creategame/{id}\")\n    public String createBoardGame(@PathVariable(\"id\") String gameTitle, Optional&lt;BoardGame&gt; game){\n        if(boardGameService.getGameByGameTitle(gameTitle) != null){\n            return \"Already on DB\";\n        }\n        if(game.isPresent()) {\n            boardGameService.addBoardGameToDB(game.get());\n            //TODO: add a confirmation message with redirection\n        }\n        return \"redirect:/boardgames/creategame\";\n    }\n\n    @GetMapping(value = \"/id/{id}\")\n    public String getGameByID(@PathVariable(\"id\") String id, Model containerToView) {\n        BoardGame gameFromDB = boardGameService.getGameByID(id);\n        containerToView.addAttribute(\"boardgame\", gameFromDB);\n        return \"boardgames/gameDetails\";\n    }\n    @GetMapping(value = \"game/{gameTitle}\")\n    public String getByGameTitle(@PathVariable(\"gameTitle\") String gameTitle, Model containerToView) {\n        BoardGame gameFromDB = boardGameService.getGameByGameTitle(gameTitle);\n        containerToView.addAttribute(\"boardgame\", gameFromDB);\n        return \"boardgames/gameDetails\";\n    }\n\n    @GetMapping(\"/deleteGame/{id}\")\n    public String deleteGame(@PathVariable(\"id\") String id) {\n        BoardGame toDelete = boardGameService.getGameByID(id);\n        boardGameService.deleteGameFromDB(toDelete);\n        return \"redirect:/boardgames/\";\n    }\n\n    @GetMapping(value = \"/updategame/{id}\")\n    public String updateBoardGame(@PathVariable(\"id\") String id, Model containerToView) {\n        // Retrieve the user based on the provided ID\n            BoardGame gameFromDB = boardGameService.getGameByID(id);\n            containerToView.addAttribute(\"boardgame\", gameFromDB);\n            return \"boardgames/updategame\";\n        }\n\n    @PostMapping(value = \"/updategame/{id}\")\n    public String updateBoardGame(@PathVariable(\"id\") String id, Optional&lt;BoardGame&gt; updatedGame) {\n        BoardGame gameToUpdate = boardGameService.getGameByID(id);\n\n        if (updatedGame.isPresent()) {\n            if (gameToUpdate != null  && updatedGame.get().getGameID().equals(gameToUpdate.getGameID())) {\n                boardGameService.updateGameFromDB(updatedGame.get());\n            }\n        }\n        // Redirect to the GET method\n        return \"redirect:/boardgames/updategame/\" + id;\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server BoardGame templates\n\n\n\nGameplay is the class that will manage the plays that user’s can publish and record in our service.\nGameplays Controller and server endpoints implementation\nStill under developement\npackage org.teamcifo.tindergames.gamePlayEntity;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.userEntity.UserService;\n\nimport java.util.Optional;\nimport java.util.Set;\n\n@Controller\n@RequestMapping(\"/gameplays\")\npublic class GameplayController {\n    @Autowired\n    GameplayService gameplayService;\n    @Autowired\n    UserService userService;\n\n    // Index page\n    /**\n     * Gameplay controller main page\n     * @param containerToView contains relevant data to correctly render Thymeleaf view\n     * @return the main page HTML file\n     */\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"gameplaysFromController\", gameplayService.getAllGameplays());\n        return \"gameplays/index\";\n    }\n\n    // CRUD operations\n    // - Create a new gameplay:\n\n    /**\n     * Gameplay's creation GET method. It initializes a new gameplay so it can be populated\n     * @param containerToView contains relevant data for correctly render Thymeleaf view\n     * @return the gameplay's creation form HTML file\n     */\n    @GetMapping(\"/createGameplay\")\n    public String createGameplay(Model containerToView) {\n        containerToView.addAttribute(\"gameplay\", new Gameplay());\n        // TODO: Add available games to select from!\n        containerToView.addAttribute(\"availablePlayers\", userService.getAllUsers());\n        containerToView.addAttribute(\"operation\", \"createGameplay\");\n        return \"gameplays/gameplayForm\";\n    }\n\n    /**\n     * Gameplay's creation POST method. Based on the given ID, if it doesn't exist, the newGameplay is stored in the DB\n     * @param id is the ID of the new Gameplay\n     * @param newGameplay is the new Gameplay object\n     * @param redirectAttributes contains the response message to be rendered in the GET method when finished\n     * @return a redirect to the GET method\n     */\n    @PostMapping(\"/createGameplay/{id}\")\n    public String createGameplay(@PathVariable(\"id\") String id, Optional&lt;Gameplay&gt; newGameplay, @RequestParam(\"players\") Set&lt;User&gt; players, RedirectAttributes redirectAttributes) {\n        // Check that the ID is not already used inside the DB\n        if (gameplayService.getGameplayByID(id) != null) {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"GameplayID \" + id + \" already used! Try again\");\n        } else {\n            // Check that path variable ID equals the ID of the new gameplay\n            if (newGameplay.isPresent() && id.equals(newGameplay.get().getGameplayId())) {\n                // Add the gameplay along with the players to the DB\n                gameplayService.addGamePlayToDB(newGameplay.get(), players);\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay \" + newGameplay.get().getGameplayId() + \" saved\");\n            } else {\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Received object doesn't contain a gameplay or something wrong with the provided IDs!\");\n            }\n        }\n        return \"redirect:/gameplays/createGameplay\";\n    }\n\n    // - Read an existing gameplay by ID:\n    /**\n     * Retrieve the Gameplay object based on the provided ID\n     * @param id is the ID of the desired Gameplay\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(\"/id/{id}\")\n    public String getGameplayByID(@PathVariable(\"id\") String id, Model containerToView) {\n        Gameplay gameplayFromDB = gameplayService.getGameplayByID(id);\n        containerToView.addAttribute(\"gameplay\", gameplayFromDB);\n        if (gameplayFromDB != null) {\n            containerToView.addAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" found\");\n        } else {\n            containerToView.addAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" not found!\");\n        }\n        return \"gameplays/gameplayDetails\";\n    }\n\n    // - Update an existing gameplay by ID\n    /**\n     * Gameplay's update GET method. Based on the proivded ID, if the gameplay exists, it will be retrieved and presented in a form for further modification\n     * @param id is the gameplay-to-update ID\n     * @param containerToView contains the Gameplay object that matches the given ID\n     * @param redirectAttributes contains the response message of the operation\n     * @param request contains the HTTP ServletRequest information, useful to redirect to the previous page\n     * @return the path to the User update form if the gameplay exists, or a redirect to the previous page otherwise\n     */\n    @GetMapping(\"/updateGameplay/{id}\")\n    public String updateGameplay(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes, HttpServletRequest request) {\n        // Check if the ID exists in the DB\n        Gameplay gameplayFromDB = gameplayService.getGameplayByID(id);\n        if (gameplayFromDB != null) {\n            // Store the gameplay object and go to the update form\n            containerToView.addAttribute(\"gameplay\", gameplayFromDB);\n            containerToView.addAttribute(\"operation\", \"updateGameplay\");\n            return \"gameplays/gameplayForm\";\n        } else {\n            // Redirect the user to the previous page\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" not found!\");\n            // Return to the previous page\n            // TODO: Secure this as the referer isn't always provided by the browser\n            return \"redirect:\" + request.getHeader(\"Referer\");\n        }\n    }\n\n    /**\n     * Gameplay's update POST method. Based on the provided ID, if the gameplay exists into the DB, it is replaced with the updated one\n     * @param id is the ID of the gameplay to update\n     * @param updatedGameplay is the Gameplay object with the updated values\n     * @param redirectAttributes contains the response message\n     * @return the path to the GET method\n     */\n    @PostMapping(\"/updateGameplay/{id}\")\n    public String updateGameplay(@PathVariable(\"id\") String id, Optional&lt;Gameplay&gt; updatedGameplay, RedirectAttributes redirectAttributes) {\n        // Only act if a gameplay has been sent and IDs match\n        if (updatedGameplay.isPresent() && id.equals(updatedGameplay.get().getGameplayId())) {\n            // Try to update the gameplay\n            if (gameplayService.updateGameplayInDB(updatedGameplay.get())) {\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" updated\");\n            } else {\n                // Something wrong when trying to update the Gameplay on database\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"GameplayID \" + id + \" wasn't updated!\");\n            }\n        } else {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Received object doesn't contain a gameplay or IDs don't match!\");\n        }\n        // Redirect to the GET method\n        return \"redirect:/gameplays/updateGameplay/\" + id;\n    }\n\n    /**\n     * Gameplay's deletion method based on its ID. If the ID exists, the gameplay is removed from the DB\n     * @param id is the ID of the gameplay to delete\n     * @param redirectAttributes\n     * @return\n     */\n    @GetMapping(\"/deleteGameplay/{id}\")\n    public String deleteGameplay(@PathVariable(\"id\") String id, RedirectAttributes redirectAttributes) {\n        if (gameplayService.deleteGameplayByIDFromDB(id)) {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" deleted\");\n        } else {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" couldn't be deleted!\");\n        }\n        // Return to the previous page\n        return \"redirect:/gameplays\";\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server Gameplays templates"
  },
  {
    "objectID": "backend/controllers.html#user",
    "href": "backend/controllers.html#user",
    "title": "Controller",
    "section": "",
    "text": "User Controller and server endpoints implementation.\nUser has a login sesion implementation.\npackage org.teamcifo.tindergames.userEntity;\n\nimport jakarta.servlet.http.HttpSession;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport java.util.*;\n\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    private String IS_LOGGED_IN = \"isLoggedIn\";\n    private static final String RESPONSE_MESSAGE = \"responseMessage\";\n    @Autowired\n    UserService userService;\n\n    private final Set&lt;String&gt; sessionIds = Collections.synchronizedSet(new HashSet&lt;&gt;());\n\n    // Index page\n    /**\n     * Users controller main page\n     * @param containerToView contains relevant data to correctly render Thymeleaf view\n     * @return the main page HTML file\n     */\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"usersFromController\", userService.getAllUsers());\n        return \"users/index\";\n    }\n\n    // CRUD operations\n    // - Create a new user:\n    /**\n     * User's creation GET method. It initializes a new user so it can be populated\n     * @param containerToView contains the new empty User\n     * @return the user's creation form HTML file\n     */\n    @GetMapping(value = {\"/createUser\", \"/createUser/\"})\n    public String createUser(Model containerToView) {\n        containerToView.addAttribute(\"user\", new User());\n        containerToView.addAttribute(\"operation\", \"createUser\");\n        return \"users/userForm\";\n    }\n\n    /**\n     * User's creation POST method. If the newUser ID doesn't exist, the newUser object is stored in the DB\n     * @param id is the ID of the new User (obsolete)\n     * @param newUser is the new User object\n     * @param redirectAttributes contains the response message to be rendered in the GET method when finished\n     * @return a redirect to the GET method\n     */\n    @PostMapping(value = \"/createUser/{id}\")\n    public String createUser(@PathVariable(\"id\") String id, Optional&lt;User&gt; newUser, RedirectAttributes redirectAttributes) {\n        // Check that the ID is not already used inside the DB\n        if (newUser.isPresent() && userService.getUserByID(newUser.get().getUserId()) == null) {\n            userService.addUserToDB(newUser.get());\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + newUser.get().getUsername() + \" saved\");\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Received object doesn't contain a user or User ID \" + newUser.get().getUserId() + \" already in DB!\");\n        }\n        return \"redirect:/users/createUser\";\n    }\n\n    // - Read an existing user by ID\n    /**\n     * Retrieve the User object based on the provided ID\n     * @param id is the ID of the desired User\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(value = \"/id/{id}\")\n    public String getUserByID(@PathVariable(\"id\") String id, Model containerToView) {\n        User userFromDB = userService.getUserByID(id);\n        containerToView.addAttribute(\"user\", userFromDB);\n        if (userFromDB != null) {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" found\");\n        } else {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n        }\n        return \"users/userDetails\";\n    }\n\n    // - Read an existing user by username\n    /**\n     * Retrieve the User object based on the provided username\n     * @param username is the username of the desired User\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(value = \"/username/{username}\")\n    public String getUserByUsername(@PathVariable(\"username\") String username, Model containerToView) {\n        User userFromDB = userService.getUserByUsername(username);\n        containerToView.addAttribute(\"user\", userFromDB);\n        if (userFromDB != null) {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"Username \" + username + \" found\");\n        } else {\n            containerToView.addAttribute(RESPONSE_MESSAGE, \"Username \" + username + \" not found!\");\n        }\n        return \"users/userDetails\";\n    }\n\n    // - Update an existing user by ID\n    /**\n     * User's update GET method. Based on the provided ID, if the user exists, it will be retrieved and presented in a\n     * form for further modification.\n     * @param id is the user-to-update ID\n     * @param containerToView contains the User object that matches the given ID\n     * @param redirectAttributes contains the response message of the operation\n     * @return the path to the User update form if the user exists, or a redirect to the User's main page otherwise\n     */\n    @GetMapping(value = \"/updateUser/{id}\")\n    public String updateUser(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userFromDB = userService.getUserByID(id);\n        if (userFromDB != null) {\n            // Store the user object and go to the update form\n            containerToView.addAttribute(\"user\", userFromDB);\n            containerToView.addAttribute(\"operation\", \"updateUser\");\n            return \"users/userForm\";\n        } else {\n            // Redirect the user to the main page\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n            return \"redirect:/users/\";\n        }\n    }\n\n    /**\n     * User's update POST method. Based on the provided ID, if the user exists into the DB, it is replaced\n     * with the updated one\n     * @param id is the ID of the user to update\n     * @param updatedUser is the User object with the updated values\n     * @param redirectAttr contains the response message\n     * @return the path to the GET method\n     */\n    @PostMapping(value = \"/updateUser/{id}\")\n    public String updateUser(@PathVariable(\"id\") String id, Optional&lt;User&gt; updatedUser, RedirectAttributes redirectAttr) {\n        // Retrieve the user based on the provided ID\n        User userToUpdate = userService.getUserByID(id);\n        if (updatedUser.isPresent()) {\n            // Check if the User already exists and the IDs are equal\n            if (userToUpdate != null && updatedUser.get().getUserId().equals(userToUpdate.getUserId())) {\n                // Update the user\n                userService.updateUserInDB(updatedUser.get());\n                // Return response message\n                redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + updatedUser.get().getUsername() + \" updated\");\n            } else {\n                // Something wrong with the ID or the Database\n                redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"UserID \" + id + \" not found or doesn't match the DB\");\n            }\n        } else {\n            // Something wrong with the updated object\n            redirectAttr.addFlashAttribute(RESPONSE_MESSAGE, \"Received object doesn't contain a user!\");\n        }\n        // Redirect to the GET method\n        return \"redirect:/users/updateUser/\" + id;\n    }\n\n    /**\n     * User's deletion method based on its ID. If the ID exists, the user is removed from the DB\n     * @param id is the ID of the user to delete\n     * @param redirectAttributes include the response message of the operation\n     * @return redirects to the user's main page to show the updated list of users\n     */\n    @GetMapping(\"/deleteUser/{id}\")\n    public String deleteUser(@PathVariable(\"id\") String id, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userToDelete = userService.getUserByID(id);\n        if (userService.deleteUserFromDB(userToDelete)) {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + userToDelete.getUsername() + \" deleted\");\n        }\n        else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User \" + userToDelete.getUsername() + \" couldn't be deleted!\");\n        }\n        // Return to the users main page\n        return \"redirect:/users/\";\n    }\n\n    // Log In endpoint\n    @GetMapping(\"login\")\n    public String logIn(HttpSession session, Model containerToView) {\n        session.setAttribute(IS_LOGGED_IN, false);\n        return \"users/userLogin\";\n    }\n\n    @PostMapping(\"login\")\n    public String logIn(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password, HttpSession session, RedirectAttributes redirectAttributes) {\n        // Check if the username and passwords are correct\n        User loggedUser = userService.logIn(username, password);\n        if (loggedUser != null && !this.sessionIds.contains(session.getId())) {\n            // Add the HTTP session id to the sessions set\n            this.sessionIds.add(session.getId());\n            // Set the login value to true\n            session.setAttribute(IS_LOGGED_IN, true);\n            // Save useful user attributes in the HTTP session\n            session.setAttribute(\"userId\", loggedUser.getUserId());\n            session.setAttribute(\"username\", loggedUser.getUsername());\n            // Return to the index page\n            return \"index\";\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Username or password incorrect\");\n            // Redirect to the login page\n            return \"redirect:/users/login\";\n        }\n\n    }\n\n    @GetMapping(\"/logout\")\n    public String logout(HttpSession session) {\n        // Restart the session attributes\n        session.removeAttribute(IS_LOGGED_IN);\n        session.removeAttribute(\"userId\");\n        session.removeAttribute(\"username\");\n        // Remove the current session from the sessions set\n        this.sessionIds.remove(session.getId());\n        // Return to the main page and force the login again\n        return \"redirect:/\";\n    }\n\n    // Other user operations\n    @GetMapping(\"resetPassword/{id}\")\n    public String resetPassword(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes) {\n        // Retrieve the user based on the provided ID\n        User userFromDB = userService.getUserByID(id);\n        if (userFromDB != null) {\n            containerToView.addAttribute(\"userId\", id);\n            containerToView.addAttribute(\"oldPassword\", userFromDB.getPassword());\n            return \"users/resetPassword\";\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n            return \"redirect:/users\";\n        }\n    }\n\n    @PostMapping(\"resetPassword/{id}\")\n    public String resetPassword(@PathVariable(\"id\") String id, @RequestParam(\"newPassword\") String newPassword, RedirectAttributes redirectAttributes) {\n        // Try to update the user's password\n        if (userService.updateUserPassword(id, newPassword)) {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Password for user ID \" + id + \" updated\");\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User ID \" + id + \" not found!\");\n        }\n        return \"redirect:/users\";\n    }\n\n    // Add friends to the User's profile\n    @GetMapping(\"addFriends/{id}\")\n    public String addFriends(@PathVariable(\"id\") String userId, HttpSession session, Model containerToView, RedirectAttributes redirectAttributes) {\n        if ((boolean) session.getAttribute(IS_LOGGED_IN) && userId.equals(session.getAttribute(\"userId\"))) {\n            if (userService.getUserByID(userId) != null) {\n                // Include both the current friend's list, the user ID and the list of available users to the frontend\n                containerToView.addAttribute(\"currentFriends\", userService.getUserFriends(userId));\n                containerToView.addAttribute(\"availableFriends\", userService.getAllUsers());\n                // TODO: remove userId from Model as it should be already available in the HttpSession --&gt; Modify frontend accordingly\n                containerToView.addAttribute(\"userId\", userId);\n                containerToView.addAttribute(RESPONSE_MESSAGE, \"User ID \" + userId + \" found\");\n                return \"users/friendsForm\";\n            } else {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in! Cancelling friend's update\");\n                return \"redirect:/users/id\" + userId;\n            }\n        }\n        redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in! Cancelling friend's update\");\n        return \"redirect:/users/id\" + userId;\n    }\n\n    @PostMapping(\"addFriends/{id}\")\n    public String addFriend(@PathVariable(\"id\") String userId, @RequestParam(\"friendsIds\") List&lt;String&gt; friendsIds, HttpSession session, RedirectAttributes redirectAttributes) {\n        // Only add friends if the user is logged in and the ID received is the same as the one from the current session\n        if ((boolean) session.getAttribute(IS_LOGGED_IN) && userId.equals(session.getAttribute(\"userId\"))) {\n            if (userService.addFriends(userId, friendsIds)) {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"Friends added to user's profile!\");\n            } else {\n                redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not found in DB, friend's update cancelled\");\n            }\n        } else {\n            redirectAttributes.addFlashAttribute(RESPONSE_MESSAGE, \"User not logged in, friend's update cancelled\");\n        }\n        return \"redirect:/users/id/\" + userId;\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server User templates"
  },
  {
    "objectID": "backend/controllers.html#boardgame",
    "href": "backend/controllers.html#boardgame",
    "title": "Controller",
    "section": "",
    "text": "BoardGame Controller and server endpoints implementation\npackage org.teamcifo.tindergames.boardGameEntity;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\nimport org.teamcifo.tindergames.userEntity.User;\n\nimport java.util.ArrayList;\nimport java.util.Optional;\n\n@Controller\n@RequestMapping(\"/boardgames\")\npublic class BoardGameController {\n    @Autowired\n    BoardGameService boardGameService;\n\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"boardGamesFromController\", boardGameService.getAllBoardGames());\n        return \"boardgames/index\";\n    }\n\n    @GetMapping(value = {\"/creategame\", \"/creategame/\"})\n    public String createBoardGame(Model containerToView) {\n        containerToView.addAttribute(\"boardgame\", new BoardGame());\n        containerToView.addAttribute(\"operation\", \"creategame\");\n        return \"boardgames/creategame.html\";\n    }\n\n    @PostMapping(value = \"/creategame/{id}\")\n    public String createBoardGame(@PathVariable(\"id\") String gameTitle, Optional&lt;BoardGame&gt; game){\n        if(boardGameService.getGameByGameTitle(gameTitle) != null){\n            return \"Already on DB\";\n        }\n        if(game.isPresent()) {\n            boardGameService.addBoardGameToDB(game.get());\n            //TODO: add a confirmation message with redirection\n        }\n        return \"redirect:/boardgames/creategame\";\n    }\n\n    @GetMapping(value = \"/id/{id}\")\n    public String getGameByID(@PathVariable(\"id\") String id, Model containerToView) {\n        BoardGame gameFromDB = boardGameService.getGameByID(id);\n        containerToView.addAttribute(\"boardgame\", gameFromDB);\n        return \"boardgames/gameDetails\";\n    }\n    @GetMapping(value = \"game/{gameTitle}\")\n    public String getByGameTitle(@PathVariable(\"gameTitle\") String gameTitle, Model containerToView) {\n        BoardGame gameFromDB = boardGameService.getGameByGameTitle(gameTitle);\n        containerToView.addAttribute(\"boardgame\", gameFromDB);\n        return \"boardgames/gameDetails\";\n    }\n\n    @GetMapping(\"/deleteGame/{id}\")\n    public String deleteGame(@PathVariable(\"id\") String id) {\n        BoardGame toDelete = boardGameService.getGameByID(id);\n        boardGameService.deleteGameFromDB(toDelete);\n        return \"redirect:/boardgames/\";\n    }\n\n    @GetMapping(value = \"/updategame/{id}\")\n    public String updateBoardGame(@PathVariable(\"id\") String id, Model containerToView) {\n        // Retrieve the user based on the provided ID\n            BoardGame gameFromDB = boardGameService.getGameByID(id);\n            containerToView.addAttribute(\"boardgame\", gameFromDB);\n            return \"boardgames/updategame\";\n        }\n\n    @PostMapping(value = \"/updategame/{id}\")\n    public String updateBoardGame(@PathVariable(\"id\") String id, Optional&lt;BoardGame&gt; updatedGame) {\n        BoardGame gameToUpdate = boardGameService.getGameByID(id);\n\n        if (updatedGame.isPresent()) {\n            if (gameToUpdate != null  && updatedGame.get().getGameID().equals(gameToUpdate.getGameID())) {\n                boardGameService.updateGameFromDB(updatedGame.get());\n            }\n        }\n        // Redirect to the GET method\n        return \"redirect:/boardgames/updategame/\" + id;\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server BoardGame templates"
  },
  {
    "objectID": "backend/controllers.html#gameplay",
    "href": "backend/controllers.html#gameplay",
    "title": "Controller",
    "section": "",
    "text": "Gameplay is the class that will manage the plays that user’s can publish and record in our service.\nGameplays Controller and server endpoints implementation\nStill under developement\npackage org.teamcifo.tindergames.gamePlayEntity;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.userEntity.UserService;\n\nimport java.util.Optional;\nimport java.util.Set;\n\n@Controller\n@RequestMapping(\"/gameplays\")\npublic class GameplayController {\n    @Autowired\n    GameplayService gameplayService;\n    @Autowired\n    UserService userService;\n\n    // Index page\n    /**\n     * Gameplay controller main page\n     * @param containerToView contains relevant data to correctly render Thymeleaf view\n     * @return the main page HTML file\n     */\n    @RequestMapping({\"/\", \"\"})\n    public String index(Model containerToView) {\n        // Retrieve all available users\n        containerToView.addAttribute(\"gameplaysFromController\", gameplayService.getAllGameplays());\n        return \"gameplays/index\";\n    }\n\n    // CRUD operations\n    // - Create a new gameplay:\n\n    /**\n     * Gameplay's creation GET method. It initializes a new gameplay so it can be populated\n     * @param containerToView contains relevant data for correctly render Thymeleaf view\n     * @return the gameplay's creation form HTML file\n     */\n    @GetMapping(\"/createGameplay\")\n    public String createGameplay(Model containerToView) {\n        containerToView.addAttribute(\"gameplay\", new Gameplay());\n        // TODO: Add available games to select from!\n        containerToView.addAttribute(\"availablePlayers\", userService.getAllUsers());\n        containerToView.addAttribute(\"operation\", \"createGameplay\");\n        return \"gameplays/gameplayForm\";\n    }\n\n    /**\n     * Gameplay's creation POST method. Based on the given ID, if it doesn't exist, the newGameplay is stored in the DB\n     * @param id is the ID of the new Gameplay\n     * @param newGameplay is the new Gameplay object\n     * @param redirectAttributes contains the response message to be rendered in the GET method when finished\n     * @return a redirect to the GET method\n     */\n    @PostMapping(\"/createGameplay/{id}\")\n    public String createGameplay(@PathVariable(\"id\") String id, Optional&lt;Gameplay&gt; newGameplay, @RequestParam(\"players\") Set&lt;User&gt; players, RedirectAttributes redirectAttributes) {\n        // Check that the ID is not already used inside the DB\n        if (gameplayService.getGameplayByID(id) != null) {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"GameplayID \" + id + \" already used! Try again\");\n        } else {\n            // Check that path variable ID equals the ID of the new gameplay\n            if (newGameplay.isPresent() && id.equals(newGameplay.get().getGameplayId())) {\n                // Add the gameplay along with the players to the DB\n                gameplayService.addGamePlayToDB(newGameplay.get(), players);\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay \" + newGameplay.get().getGameplayId() + \" saved\");\n            } else {\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Received object doesn't contain a gameplay or something wrong with the provided IDs!\");\n            }\n        }\n        return \"redirect:/gameplays/createGameplay\";\n    }\n\n    // - Read an existing gameplay by ID:\n    /**\n     * Retrieve the Gameplay object based on the provided ID\n     * @param id is the ID of the desired Gameplay\n     * @param containerToView contains the User data from the DB as well as the response message\n     * @return the path to the User Details HTML file\n     */\n    @GetMapping(\"/id/{id}\")\n    public String getGameplayByID(@PathVariable(\"id\") String id, Model containerToView) {\n        Gameplay gameplayFromDB = gameplayService.getGameplayByID(id);\n        containerToView.addAttribute(\"gameplay\", gameplayFromDB);\n        if (gameplayFromDB != null) {\n            containerToView.addAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" found\");\n        } else {\n            containerToView.addAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" not found!\");\n        }\n        return \"gameplays/gameplayDetails\";\n    }\n\n    // - Update an existing gameplay by ID\n    /**\n     * Gameplay's update GET method. Based on the proivded ID, if the gameplay exists, it will be retrieved and presented in a form for further modification\n     * @param id is the gameplay-to-update ID\n     * @param containerToView contains the Gameplay object that matches the given ID\n     * @param redirectAttributes contains the response message of the operation\n     * @param request contains the HTTP ServletRequest information, useful to redirect to the previous page\n     * @return the path to the User update form if the gameplay exists, or a redirect to the previous page otherwise\n     */\n    @GetMapping(\"/updateGameplay/{id}\")\n    public String updateGameplay(@PathVariable(\"id\") String id, Model containerToView, RedirectAttributes redirectAttributes, HttpServletRequest request) {\n        // Check if the ID exists in the DB\n        Gameplay gameplayFromDB = gameplayService.getGameplayByID(id);\n        if (gameplayFromDB != null) {\n            // Store the gameplay object and go to the update form\n            containerToView.addAttribute(\"gameplay\", gameplayFromDB);\n            containerToView.addAttribute(\"operation\", \"updateGameplay\");\n            return \"gameplays/gameplayForm\";\n        } else {\n            // Redirect the user to the previous page\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay ID \" + id + \" not found!\");\n            // Return to the previous page\n            // TODO: Secure this as the referer isn't always provided by the browser\n            return \"redirect:\" + request.getHeader(\"Referer\");\n        }\n    }\n\n    /**\n     * Gameplay's update POST method. Based on the provided ID, if the gameplay exists into the DB, it is replaced with the updated one\n     * @param id is the ID of the gameplay to update\n     * @param updatedGameplay is the Gameplay object with the updated values\n     * @param redirectAttributes contains the response message\n     * @return the path to the GET method\n     */\n    @PostMapping(\"/updateGameplay/{id}\")\n    public String updateGameplay(@PathVariable(\"id\") String id, Optional&lt;Gameplay&gt; updatedGameplay, RedirectAttributes redirectAttributes) {\n        // Only act if a gameplay has been sent and IDs match\n        if (updatedGameplay.isPresent() && id.equals(updatedGameplay.get().getGameplayId())) {\n            // Try to update the gameplay\n            if (gameplayService.updateGameplayInDB(updatedGameplay.get())) {\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" updated\");\n            } else {\n                // Something wrong when trying to update the Gameplay on database\n                redirectAttributes.addFlashAttribute(\"responseMessage\", \"GameplayID \" + id + \" wasn't updated!\");\n            }\n        } else {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Received object doesn't contain a gameplay or IDs don't match!\");\n        }\n        // Redirect to the GET method\n        return \"redirect:/gameplays/updateGameplay/\" + id;\n    }\n\n    /**\n     * Gameplay's deletion method based on its ID. If the ID exists, the gameplay is removed from the DB\n     * @param id is the ID of the gameplay to delete\n     * @param redirectAttributes\n     * @return\n     */\n    @GetMapping(\"/deleteGameplay/{id}\")\n    public String deleteGameplay(@PathVariable(\"id\") String id, RedirectAttributes redirectAttributes) {\n        if (gameplayService.deleteGameplayByIDFromDB(id)) {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" deleted\");\n        } else {\n            redirectAttributes.addFlashAttribute(\"responseMessage\", \"Gameplay with ID \" + id + \" couldn't be deleted!\");\n        }\n        // Return to the previous page\n        return \"redirect:/gameplays\";\n    }\n}\nLink to HMTL template with Thymeleaf to perform CRUD operations to the server Gameplays templates"
  },
  {
    "objectID": "backend/rest-api-controllers.html",
    "href": "backend/rest-api-controllers.html",
    "title": "REST API controllers",
    "section": "",
    "text": "TODO: write an introduction to this entry\n\n\n\n\n\n\n\n\n\n\nuserRestController.java\n\npackage org.teamcifo.tindergames.userRestController;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameService;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.userEntity.UserService;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class userRestController {\n\n    @Autowired\n    UserService userService;\n    @Autowired\n    BoardGameService boardGameService;\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping({\"/\", \"\"})\n    public Iterable&lt;User&gt; getAllUsers(){\n        return userService.getAllUsers();\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"username/{username}\")\n    public User getUserByUsername(@PathVariable String username){\n        Optional&lt;User&gt; user = Optional.ofNullable(userService.getUserByUsername(username));\n        if (user.isPresent()){\n            return user.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"userID/{userID}\")\n    public User getUserByUserID(@PathVariable String userID){\n        Optional&lt;User&gt; user = Optional.ofNullable(userService.getUserByID(userID));\n        if (user.isPresent()){\n            return user.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(path=\"createUser\", consumes = \"application/JSON\")\n    public Boolean createUser(@RequestBody User user){\n        if(userService.addUserToDB(user)){\n            userService.addUserToDB(user);\n            return true;\n        }\n        return false;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"updateUser\")\n    public ResponseEntity&lt;User&gt; updateUser(@RequestBody User user){\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"updateUser\");\n        headers.add(\"version\", \"api 1.0\");\n        Optional&lt;User&gt; userToUpdate= Optional.ofNullable(userService.getUserByID(user.getUserId()));\n\n        if (userToUpdate.isPresent()){\n            userService.updateUserInDB(user);\n            headers.add(\"operationStatus\", \"updated\");\n            return  ResponseEntity.accepted().headers(headers).body(userService.getUserByID(user.getUserId()));\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteUser\")\n    public ResponseEntity&lt;Boolean&gt; deleteUser(@RequestParam(\"userID\") String userID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteUser\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFound = Optional.ofNullable(userService.getUserByID(userID));\n        if (userFound.isPresent()){\n            userService.deleteUserFromDB(userFound.get());\n            headers.add(\"operationStatus\", \"user deleted\");\n            return ResponseEntity.accepted().headers(headers).body(true);\n        }\n        return ResponseEntity.accepted().headers(headers).body(false);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteFriend\")\n    public ResponseEntity&lt;Boolean&gt; deleteFriend(@RequestParam(\"userID\") String userID, @RequestParam(\"friendID\") String friendID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteFriend\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFound = Optional.ofNullable(userService.getUserByID(userID));\n        if (userFound.isPresent()){\n            userService.deleteFriend(userID, friendID, userFound.get().getFriends());\n            return ResponseEntity.accepted().headers(headers).body(true);\n\n        }\n        return ResponseEntity.accepted().headers(headers).body(false);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"addFriends\")\n    public ResponseEntity&lt;User&gt; addFriend(@RequestParam(\"userID\") String userID, @RequestParam(\"friendsIds\") List&lt;String&gt; friendsIds){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"addFriend\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFormDB = Optional.ofNullable(userService.getUserByID(userID));\n        if(userFormDB.isPresent()){\n            userService.addFriends(userFormDB.get().getUserId(), friendsIds);\n            return ResponseEntity.accepted().headers(headers).body(userFormDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"addGameToCollection\")\n    public ResponseEntity&lt;User&gt; addGameToCollection(@RequestParam(\"userID\") String userID, @RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"addGameToUserCollection\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFromDB = Optional.ofNullable(userService.getUserByID(userID));\n        Optional&lt;BoardGame&gt; gameFromDB = Optional.ofNullable(boardGameService.getGameByID(gameID));\n        if (userFromDB.isPresent() && gameFromDB.isPresent()){\n            userFromDB.get().addGameToCollection(gameFromDB.get());\n            updateUser(userFromDB.get());\n            return ResponseEntity.accepted().headers(headers).body(userFromDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"deleteGameFromCollection\")\n    public ResponseEntity&lt;User&gt; deleteGameFromCollection(@RequestParam(\"userID\") String userID, @RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteGameFromCollection\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFromDB = Optional.ofNullable(userService.getUserByID(userID));\n        Optional&lt;BoardGame&gt; gameFromDB = Optional.ofNullable(boardGameService.getGameByID(gameID));\n        if (userFromDB.isPresent() && gameFromDB.isPresent()){\n            userFromDB.get().deleteGameFromCollection(gameFromDB.get());\n            updateUser(userFromDB.get());\n            return ResponseEntity.accepted().headers(headers).body(userFromDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(\"login\")\n    public ResponseEntity&lt;User&gt; login(@RequestParam(\"username\")String username, @RequestParam(\"password\")String password){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"login\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; loginUser = Optional.ofNullable(userService.logIn(username, password));\n        if(loginUser.isPresent()){\n            return ResponseEntity.accepted().headers(headers).body(loginUser.get());\n        }\n\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n}\n// https://stackoverflow.com/questions/34946237/how-delete-object-in-one-side-at-bidirectional-relation\n\n\n\n\n\n\nBoardGameRestController.java\n\npackage org.teamcifo.tindergames.boardGameRestController;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameController;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameService;\n\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(\"/api/boardgames\")\npublic class BoardGameRestController {\n\n    @Autowired\n    BoardGameService gameService;\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping({\"/\", \"\"})\n    public Iterable&lt;BoardGame&gt; getAllGames(){\n        return gameService.getAllBoardGames();\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"title/{gameTitle}\")\n    public BoardGame getGameByTitle(@PathVariable String gameTitle){\n        Optional&lt;BoardGame&gt; game = Optional.ofNullable(gameService.getGameByGameTitle(gameTitle));\n        if (game.isPresent()){\n            return game.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"id/{gameID}\")\n    public BoardGame getGameByID(@PathVariable String gameID){\n        Optional&lt;BoardGame&gt; game = Optional.ofNullable(gameService.getGameByID(gameID));\n        if (game.isPresent()){\n            return game.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(path=\"createGame\", consumes = \"application/JSON\")\n    public BoardGame createGame(@RequestBody BoardGame game){\n        BoardGame newGame = gameService.createGame(game);\n        return newGame;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteGame\")\n    public ResponseEntity&lt;BoardGame&gt; deleteGame(@RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteGame\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;BoardGame&gt; gameFound = Optional.ofNullable(gameService.getGameByID(gameID));\n        if (gameFound.isPresent()){\n            gameService.deleteGameFromDB(gameFound.get());\n            headers.add(\"operationStatus\", \"deleted\");\n            return ResponseEntity.accepted().headers(headers).body(gameFound.get());\n        }\n        return ResponseEntity.accepted().body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"updateGame\")\n    public ResponseEntity&lt;BoardGame&gt; updateGame(@RequestBody BoardGame game){\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"updateGame\");\n        headers.add(\"version\", \"api 1.0\");\n        Optional&lt;BoardGame&gt; gameFromDB= Optional.ofNullable(gameService.getGameByID(game.getGameID()));\n\n        if (gameFromDB.isPresent()){\n            gameService.updateGameFromDB(game);\n            headers.add(\"operationStatus\", \"updated\");\n            return  ResponseEntity.accepted().headers(headers).body(gameService.getGameByID(game.getGameID()));\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n}\n\n\n\n\nGET api/boardgames - fetch all boardgames\nGET api/boardgames/title/{gameTitle} - fetch a board game by title\nGET api/boardgames/id/{gameID} - fetch by gameID\nPOST api/boardgames/createGame{BoardGame}\nDELETE api/boardgames/deleteGame{gameID}\nPUT api/boardgames/updateGame{BoardGame}\n\n\n\n\n\nGET user/users/ - fetch all users\nGET user/users/userID/{userID} - fetch user by userID\nGET user/users/username/{username} - fetch user by username\nPOST user/users/createUser{User}\nPUT user/users/updateUser{User}\nDELETE api/boardgames/deleteUser/{userID}\nDELETE api/boardgames/deleteFriend{userID}{friendID} - deletes a friend from user’s friend’s list\nPUT api/boardgames/addFriends{userID}{friendsIds} - recieves a userID and a list of friendId’s\nPUT api/boardgames/addGameToCollection{userID}{gameID}\nPUT api/boardgames/deleteGameFromCollection{userID}{gameID}\nPOST api/boardgames/login{username}{password}"
  },
  {
    "objectID": "backend/rest-api-controllers.html#userrestcontroller",
    "href": "backend/rest-api-controllers.html#userrestcontroller",
    "title": "REST API controllers",
    "section": "",
    "text": "userRestController.java\n\npackage org.teamcifo.tindergames.userRestController;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameService;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.userEntity.UserService;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class userRestController {\n\n    @Autowired\n    UserService userService;\n    @Autowired\n    BoardGameService boardGameService;\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping({\"/\", \"\"})\n    public Iterable&lt;User&gt; getAllUsers(){\n        return userService.getAllUsers();\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"username/{username}\")\n    public User getUserByUsername(@PathVariable String username){\n        Optional&lt;User&gt; user = Optional.ofNullable(userService.getUserByUsername(username));\n        if (user.isPresent()){\n            return user.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"userID/{userID}\")\n    public User getUserByUserID(@PathVariable String userID){\n        Optional&lt;User&gt; user = Optional.ofNullable(userService.getUserByID(userID));\n        if (user.isPresent()){\n            return user.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(path=\"createUser\", consumes = \"application/JSON\")\n    public Boolean createUser(@RequestBody User user){\n        if(userService.addUserToDB(user)){\n            userService.addUserToDB(user);\n            return true;\n        }\n        return false;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"updateUser\")\n    public ResponseEntity&lt;User&gt; updateUser(@RequestBody User user){\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"updateUser\");\n        headers.add(\"version\", \"api 1.0\");\n        Optional&lt;User&gt; userToUpdate= Optional.ofNullable(userService.getUserByID(user.getUserId()));\n\n        if (userToUpdate.isPresent()){\n            userService.updateUserInDB(user);\n            headers.add(\"operationStatus\", \"updated\");\n            return  ResponseEntity.accepted().headers(headers).body(userService.getUserByID(user.getUserId()));\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteUser\")\n    public ResponseEntity&lt;Boolean&gt; deleteUser(@RequestParam(\"userID\") String userID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteUser\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFound = Optional.ofNullable(userService.getUserByID(userID));\n        if (userFound.isPresent()){\n            userService.deleteUserFromDB(userFound.get());\n            headers.add(\"operationStatus\", \"user deleted\");\n            return ResponseEntity.accepted().headers(headers).body(true);\n        }\n        return ResponseEntity.accepted().headers(headers).body(false);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteFriend\")\n    public ResponseEntity&lt;Boolean&gt; deleteFriend(@RequestParam(\"userID\") String userID, @RequestParam(\"friendID\") String friendID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteFriend\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFound = Optional.ofNullable(userService.getUserByID(userID));\n        if (userFound.isPresent()){\n            userService.deleteFriend(userID, friendID, userFound.get().getFriends());\n            return ResponseEntity.accepted().headers(headers).body(true);\n\n        }\n        return ResponseEntity.accepted().headers(headers).body(false);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"addFriends\")\n    public ResponseEntity&lt;User&gt; addFriend(@RequestParam(\"userID\") String userID, @RequestParam(\"friendsIds\") List&lt;String&gt; friendsIds){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"addFriend\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFormDB = Optional.ofNullable(userService.getUserByID(userID));\n        if(userFormDB.isPresent()){\n            userService.addFriends(userFormDB.get().getUserId(), friendsIds);\n            return ResponseEntity.accepted().headers(headers).body(userFormDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"addGameToCollection\")\n    public ResponseEntity&lt;User&gt; addGameToCollection(@RequestParam(\"userID\") String userID, @RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"addGameToUserCollection\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFromDB = Optional.ofNullable(userService.getUserByID(userID));\n        Optional&lt;BoardGame&gt; gameFromDB = Optional.ofNullable(boardGameService.getGameByID(gameID));\n        if (userFromDB.isPresent() && gameFromDB.isPresent()){\n            userFromDB.get().addGameToCollection(gameFromDB.get());\n            updateUser(userFromDB.get());\n            return ResponseEntity.accepted().headers(headers).body(userFromDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"deleteGameFromCollection\")\n    public ResponseEntity&lt;User&gt; deleteGameFromCollection(@RequestParam(\"userID\") String userID, @RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteGameFromCollection\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; userFromDB = Optional.ofNullable(userService.getUserByID(userID));\n        Optional&lt;BoardGame&gt; gameFromDB = Optional.ofNullable(boardGameService.getGameByID(gameID));\n        if (userFromDB.isPresent() && gameFromDB.isPresent()){\n            userFromDB.get().deleteGameFromCollection(gameFromDB.get());\n            updateUser(userFromDB.get());\n            return ResponseEntity.accepted().headers(headers).body(userFromDB.get());\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(\"login\")\n    public ResponseEntity&lt;User&gt; login(@RequestParam(\"username\")String username, @RequestParam(\"password\")String password){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"login\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;User&gt; loginUser = Optional.ofNullable(userService.logIn(username, password));\n        if(loginUser.isPresent()){\n            return ResponseEntity.accepted().headers(headers).body(loginUser.get());\n        }\n\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n}\n// https://stackoverflow.com/questions/34946237/how-delete-object-in-one-side-at-bidirectional-relation"
  },
  {
    "objectID": "backend/rest-api-controllers.html#boardgamerestcontroller",
    "href": "backend/rest-api-controllers.html#boardgamerestcontroller",
    "title": "REST API controllers",
    "section": "",
    "text": "BoardGameRestController.java\n\npackage org.teamcifo.tindergames.boardGameRestController;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameController;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGameService;\n\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(\"/api/boardgames\")\npublic class BoardGameRestController {\n\n    @Autowired\n    BoardGameService gameService;\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping({\"/\", \"\"})\n    public Iterable&lt;BoardGame&gt; getAllGames(){\n        return gameService.getAllBoardGames();\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"title/{gameTitle}\")\n    public BoardGame getGameByTitle(@PathVariable String gameTitle){\n        Optional&lt;BoardGame&gt; game = Optional.ofNullable(gameService.getGameByGameTitle(gameTitle));\n        if (game.isPresent()){\n            return game.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"id/{gameID}\")\n    public BoardGame getGameByID(@PathVariable String gameID){\n        Optional&lt;BoardGame&gt; game = Optional.ofNullable(gameService.getGameByID(gameID));\n        if (game.isPresent()){\n            return game.get();\n        }\n        return null;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PostMapping(path=\"createGame\", consumes = \"application/JSON\")\n    public BoardGame createGame(@RequestBody BoardGame game){\n        BoardGame newGame = gameService.createGame(game);\n        return newGame;\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @DeleteMapping(\"deleteGame\")\n    public ResponseEntity&lt;BoardGame&gt; deleteGame(@RequestParam(\"gameID\") String gameID){\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"deleteGame\");\n        headers.add(\"version\", \"api 1.0\");\n\n        Optional&lt;BoardGame&gt; gameFound = Optional.ofNullable(gameService.getGameByID(gameID));\n        if (gameFound.isPresent()){\n            gameService.deleteGameFromDB(gameFound.get());\n            headers.add(\"operationStatus\", \"deleted\");\n            return ResponseEntity.accepted().headers(headers).body(gameFound.get());\n        }\n        return ResponseEntity.accepted().body(null);\n    }\n\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @PutMapping(\"updateGame\")\n    public ResponseEntity&lt;BoardGame&gt; updateGame(@RequestBody BoardGame game){\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"operation\", \"updateGame\");\n        headers.add(\"version\", \"api 1.0\");\n        Optional&lt;BoardGame&gt; gameFromDB= Optional.ofNullable(gameService.getGameByID(game.getGameID()));\n\n        if (gameFromDB.isPresent()){\n            gameService.updateGameFromDB(game);\n            headers.add(\"operationStatus\", \"updated\");\n            return  ResponseEntity.accepted().headers(headers).body(gameService.getGameByID(game.getGameID()));\n        }\n        return ResponseEntity.accepted().headers(headers).body(null);\n    }\n}\n\n\n\n\nGET api/boardgames - fetch all boardgames\nGET api/boardgames/title/{gameTitle} - fetch a board game by title\nGET api/boardgames/id/{gameID} - fetch by gameID\nPOST api/boardgames/createGame{BoardGame}\nDELETE api/boardgames/deleteGame{gameID}\nPUT api/boardgames/updateGame{BoardGame}\n\n\n\n\n\nGET user/users/ - fetch all users\nGET user/users/userID/{userID} - fetch user by userID\nGET user/users/username/{username} - fetch user by username\nPOST user/users/createUser{User}\nPUT user/users/updateUser{User}\nDELETE api/boardgames/deleteUser/{userID}\nDELETE api/boardgames/deleteFriend{userID}{friendID} - deletes a friend from user’s friend’s list\nPUT api/boardgames/addFriends{userID}{friendsIds} - recieves a userID and a list of friendId’s\nPUT api/boardgames/addGameToCollection{userID}{gameID}\nPUT api/boardgames/deleteGameFromCollection{userID}{gameID}\nPOST api/boardgames/login{username}{password}"
  },
  {
    "objectID": "backend/uml.html",
    "href": "backend/uml.html",
    "title": "UML",
    "section": "",
    "text": "With in the first stages of the project we came to defince wiche ones where our core classes to start working on. On later stages, the original uml extended based on vertical slicing design to provide more classes taking care of busines logic of our service.\n\n\nUser, BoardGame, GamePlays and GameCollection had been defined as our core model classes and stablished the most basic relationship between them. Also, at this stage a simple vocabulary is set so all the team knows what is been discussed.\n\n\n\n\n\n\numl-v1\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\n\nAfter the core model is defined, the second stage of the desing consists on applying vertical business logic. With that vertical slicing it’s easier to see the relatonships between our classes and the scoops of concern for each entity.\n\n\n\n\n\n\numl-v2\n\n\n\n\n\n\nUML-V1\n\n\n\n\n\n\n\nUML-V2 helped to build a program that is being used as a console mockup. On V3 the developement of the web application started. All managers has been removed and replaced with Service (for business logic), Controller (managing HTTP request for administration tasks), Rest controllers (creating all the endpoints to have a working website) and a Repository (a SQL DB) :::{.callout-warning} ## uml-v3  :::"
  },
  {
    "objectID": "backend/uml.html#uml-v1",
    "href": "backend/uml.html#uml-v1",
    "title": "UML",
    "section": "",
    "text": "User, BoardGame, GamePlays and GameCollection had been defined as our core model classes and stablished the most basic relationship between them. Also, at this stage a simple vocabulary is set so all the team knows what is been discussed.\n\n\n\n\n\n\numl-v1\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "backend/uml.html#uml-v2",
    "href": "backend/uml.html#uml-v2",
    "title": "UML",
    "section": "",
    "text": "After the core model is defined, the second stage of the desing consists on applying vertical business logic. With that vertical slicing it’s easier to see the relatonships between our classes and the scoops of concern for each entity.\n\n\n\n\n\n\numl-v2\n\n\n\n\n\n\nUML-V1"
  },
  {
    "objectID": "backend/uml.html#uml-v3",
    "href": "backend/uml.html#uml-v3",
    "title": "UML",
    "section": "",
    "text": "UML-V2 helped to build a program that is being used as a console mockup. On V3 the developement of the web application started. All managers has been removed and replaced with Service (for business logic), Controller (managing HTTP request for administration tasks), Rest controllers (creating all the endpoints to have a working website) and a Repository (a SQL DB) :::{.callout-warning} ## uml-v3  :::"
  },
  {
    "objectID": "backend/classes.html",
    "href": "backend/classes.html",
    "title": "Entities",
    "section": "",
    "text": "After the first UML desing, the developement of our java application started.\n\n\n\n\n\n\nTODO: Write an introduction to this entry\n\n\n\n\n\n\n\n\nUser class has been built using lombok annotations. Has been given a Entity annotation. Also, all the annotations needed to store the object in a SQL DB has been used.\nDuring the developement we have encountered a problem with the JSON serialization and deserialization with the friend parameter. That’s why we have found a simple solution to keep building our application. At this point, we are filtering that only returns the friends list with one level of depth.\npackage org.teamcifo.tindergames.userEntity;\n\nimport com.fasterxml.jackson.annotation.JsonIdentityInfo;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\nimport org.hibernate.Hibernate;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.gamePlayEntity.Gameplay;\nimport org.teamcifo.tindergames.gamesCollectionEntity.GameStats;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.*;\n\n@AllArgsConstructor\n@Getter\n@Setter\n@ToString\n// JPA annotations\n@Entity(name=\"User\")\n@Table(name=\"USER_TABLE\")\n// annotation that filters recursive on the friends bidirectional relationship\n// link to documentation: https://www.baeldung.com/jackson-bidirectional-relationships-and-infinite-recursion#bd-json-identity-info\n\n@JsonIdentityInfo(\n        generator = ObjectIdGenerators.PropertyGenerator.class,\n        property = \"userId\")\npublic class User {\n\n    @Column\n    private String firstName, lastName, email, username;\n    @Column\n    //@JsonIgnore\n    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\n    private String password;\n    @Id\n    @GenericGenerator(name=\"system-uuid\", strategy=\"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String userId;\n\n    @OneToMany(cascade = CascadeType.ALL)\n    @JoinTable(name = \"game_statuses_mapping\",\n            joinColumns = {@JoinColumn(name = \"user_id\", referencedColumnName = \"userId\")},\n            inverseJoinColumns = {@JoinColumn(name = \"game_stats_id\", referencedColumnName = \"gameStatsId\")})\n    @MapKeyJoinColumn(name = \"game_id\")\n    @ToString.Exclude\n    private Map&lt;BoardGame, GameStats&gt; userGamesCollection; // Keys are BoardGames\n\n    @ManyToMany\n    @JoinTable(name = \"USER_GAMEPLAY\",\n            joinColumns = @JoinColumn(name = \"USER_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"GAMEPLAY_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;Gameplay&gt; gameplays;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_FRIENDS\",\n            joinColumns = @JoinColumn(name = \"USER_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"FRIEND_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;User&gt; friends;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_FRIENDS\",\n            joinColumns = @JoinColumn(name = \"FRIEND_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"USER_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;User&gt; friendOf;\n\n\n    public User() {\n        this.userId = Helpers.generateUUID();\n        this.gameplays = new HashSet&lt;&gt;();\n        this.friends = new HashSet&lt;&gt;();\n        this.friendOf = new HashSet&lt;&gt;();\n        this.userGamesCollection = new HashMap&lt;&gt;();\n    }\n\n    public User(String firstName, String lastName, String password, String email, String username) {\n        this();\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.password = password;\n        this.email = email;\n        this.username = username;\n    }\n\n    public boolean checkPassword(String password) {\n        return this.getPassword().equals(password);\n    }\n\n    public void addFriend(User friend) {\n        this.friends.add(friend);\n    }\n\n    public void deleteFriend(User friend){\n        this.friends.remove(friend);\n    }\n\n    public void addGameToCollection(BoardGame boardGame) {\n        this.userGamesCollection.putIfAbsent(boardGame, new GameStats());\n    }\n\n    public void deleteGameFromCollection(BoardGame boardGame) {\n        if (this.hasGame(boardGame)) {\n            this.userGamesCollection.remove(boardGame);\n        }\n    }\n\n    public boolean hasGame(BoardGame boardGame) {\n        return this.userGamesCollection.containsKey(boardGame);\n    }\n\n    public Set&lt;User&gt; getFriends(){\n        return this.friends;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;\n        User user = (User) o;\n        return getUserId() != null && Objects.equals(getUserId(), user.getUserId());\n    }\n\n    @Override\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n}\n\n\n\nBoardGame class with Lombok, JPA an JSON annotations used.\npackage org.teamcifo.tindergames.boardGameEntity;\n\n\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.utils.Helpers;\n\n@Data\n@AllArgsConstructor\n@Entity(name=\"BoardGame\")\n@Table(name=\"BOARDGAME_TABLE\")\n@JsonSerialize\npublic class BoardGame {\n\n    @Id\n    @GenericGenerator(name=\"system-uuid\", strategy=\"uuid\")\n    @Column(name=\"gameID\", updatable=false)\n    private String gameID;\n    @Column(name=\"gameTitle\")\n    private String gameTitle;\n    @Column(name=\"minPlayers\")\n    private int minPlayers;\n    @Column(name=\"maxPlayers\")\n    private int maxPlayers;\n    @Column(name=\"minPlayTime\")\n    private int minPlayTime;\n    @Column(name=\"maxPlayTime\")\n    private int maxPlayTime;\n\n    public BoardGame(String gameTitle){\n        this.gameID = Helpers.generateUUID();\n        this.gameTitle = gameTitle;\n        this.minPlayers = 0;\n        this.maxPlayers = 0;\n        this.minPlayTime = 0;\n        this.maxPlayTime = 0;\n    }\n    public BoardGame(String gameTitle, int minPlayers, int maxPlayers, int minPlayTime, int maxPlayTime){\n        this.gameID = Helpers.generateUUID();\n        this.gameTitle = gameTitle;\n        this.minPlayers = minPlayers;\n        this.maxPlayers = maxPlayers;\n        this.minPlayTime = minPlayTime;\n        this.maxPlayTime = maxPlayTime;\n    }\n\n    public BoardGame(){\n        this.gameID = Helpers.generateUUID();\n    }\n\n    @Override\n    @JsonValue\n    public String toString() {\n        return this.getGameTitle();\n    }\n}\n\n\n\nThis class will be used to record statistics from the games played by the user. More features and developement will be done\npackage org.teamcifo.tindergames.gamesCollectionEntity;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.Objects;\n\n@Getter\n@Setter\n// JPA annotations\n@Entity(name = \"GameStats\")\n@Table(name = \"GAME_STATS\")\npublic class GameStats {\n    @Id\n    @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String gameStatsId;\n    private double buyPrice;\n    private int numTimesPlayed;\n    private int numWins;\n    private boolean owned;\n\n    public GameStats() {\n        this.gameStatsId = Helpers.generateUUID();\n        this.buyPrice = 0.0;\n        this.numTimesPlayed = 0;\n        this.numWins = 0;\n        this.owned = false;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder stats = new StringBuilder();\n\n        stats.append(\"Price when bought:\\t\").append(this.getBuyPrice());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Number of times played:\\t\").append(this.getNumTimesPlayed());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Number of wins:\\t\").append(this.getNumWins());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Game owned:\\t\").append(this.isOwned());\n        stats.append(System.getProperty(\"line.separator\"));\n\n        return stats.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof GameStats gameStats)) return false;\n        return Double.compare(gameStats.buyPrice, buyPrice) == 0 && numTimesPlayed == gameStats.numTimesPlayed && numWins == gameStats.numWins && owned == gameStats.owned;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(buyPrice, numTimesPlayed, numWins, owned);\n    }\n}\n\n\n\nGameplay is the class that will manage the plays that user’s can publish and record in our service.\nStill under developement\npackage org.teamcifo.tindergames.gamePlayEntity;\n\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.Set;\n\n// Lombok annotations\n@Getter\n@Setter\n// JPA annotations\n@Entity(name=\"GamePlay\")\n@Table(name=\"GAMEPLAY_TABLE\")\npublic class Gameplay {\n    @Id\n    @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String gameplayId;\n    @ManyToOne\n    @JoinColumn(name = \"gameID\")\n    private BoardGame boardGame;\n    @Column\n    private Long time;\n    @ManyToOne\n    @JoinColumn(name = \"id\")\n    private User winner;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_GAMEPLAY\",\n            joinColumns = @JoinColumn(name = \"GAMEPLAY_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"USER_FK\")\n    )\n    private Set&lt;User&gt; players;\n\n    public Gameplay() {\n        this.gameplayId = Helpers.generateUUID();\n    }\n}"
  },
  {
    "objectID": "backend/classes.html#user",
    "href": "backend/classes.html#user",
    "title": "Entities",
    "section": "",
    "text": "User class has been built using lombok annotations. Has been given a Entity annotation. Also, all the annotations needed to store the object in a SQL DB has been used.\nDuring the developement we have encountered a problem with the JSON serialization and deserialization with the friend parameter. That’s why we have found a simple solution to keep building our application. At this point, we are filtering that only returns the friends list with one level of depth.\npackage org.teamcifo.tindergames.userEntity;\n\nimport com.fasterxml.jackson.annotation.JsonIdentityInfo;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\nimport org.hibernate.Hibernate;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.gamePlayEntity.Gameplay;\nimport org.teamcifo.tindergames.gamesCollectionEntity.GameStats;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.*;\n\n@AllArgsConstructor\n@Getter\n@Setter\n@ToString\n// JPA annotations\n@Entity(name=\"User\")\n@Table(name=\"USER_TABLE\")\n// annotation that filters recursive on the friends bidirectional relationship\n// link to documentation: https://www.baeldung.com/jackson-bidirectional-relationships-and-infinite-recursion#bd-json-identity-info\n\n@JsonIdentityInfo(\n        generator = ObjectIdGenerators.PropertyGenerator.class,\n        property = \"userId\")\npublic class User {\n\n    @Column\n    private String firstName, lastName, email, username;\n    @Column\n    //@JsonIgnore\n    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\n    private String password;\n    @Id\n    @GenericGenerator(name=\"system-uuid\", strategy=\"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String userId;\n\n    @OneToMany(cascade = CascadeType.ALL)\n    @JoinTable(name = \"game_statuses_mapping\",\n            joinColumns = {@JoinColumn(name = \"user_id\", referencedColumnName = \"userId\")},\n            inverseJoinColumns = {@JoinColumn(name = \"game_stats_id\", referencedColumnName = \"gameStatsId\")})\n    @MapKeyJoinColumn(name = \"game_id\")\n    @ToString.Exclude\n    private Map&lt;BoardGame, GameStats&gt; userGamesCollection; // Keys are BoardGames\n\n    @ManyToMany\n    @JoinTable(name = \"USER_GAMEPLAY\",\n            joinColumns = @JoinColumn(name = \"USER_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"GAMEPLAY_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;Gameplay&gt; gameplays;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_FRIENDS\",\n            joinColumns = @JoinColumn(name = \"USER_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"FRIEND_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;User&gt; friends;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_FRIENDS\",\n            joinColumns = @JoinColumn(name = \"FRIEND_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"USER_FK\")\n    )\n    @ToString.Exclude\n    private Set&lt;User&gt; friendOf;\n\n\n    public User() {\n        this.userId = Helpers.generateUUID();\n        this.gameplays = new HashSet&lt;&gt;();\n        this.friends = new HashSet&lt;&gt;();\n        this.friendOf = new HashSet&lt;&gt;();\n        this.userGamesCollection = new HashMap&lt;&gt;();\n    }\n\n    public User(String firstName, String lastName, String password, String email, String username) {\n        this();\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.password = password;\n        this.email = email;\n        this.username = username;\n    }\n\n    public boolean checkPassword(String password) {\n        return this.getPassword().equals(password);\n    }\n\n    public void addFriend(User friend) {\n        this.friends.add(friend);\n    }\n\n    public void deleteFriend(User friend){\n        this.friends.remove(friend);\n    }\n\n    public void addGameToCollection(BoardGame boardGame) {\n        this.userGamesCollection.putIfAbsent(boardGame, new GameStats());\n    }\n\n    public void deleteGameFromCollection(BoardGame boardGame) {\n        if (this.hasGame(boardGame)) {\n            this.userGamesCollection.remove(boardGame);\n        }\n    }\n\n    public boolean hasGame(BoardGame boardGame) {\n        return this.userGamesCollection.containsKey(boardGame);\n    }\n\n    public Set&lt;User&gt; getFriends(){\n        return this.friends;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;\n        User user = (User) o;\n        return getUserId() != null && Objects.equals(getUserId(), user.getUserId());\n    }\n\n    @Override\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n}"
  },
  {
    "objectID": "backend/classes.html#boardgame",
    "href": "backend/classes.html#boardgame",
    "title": "Entities",
    "section": "",
    "text": "BoardGame class with Lombok, JPA an JSON annotations used.\npackage org.teamcifo.tindergames.boardGameEntity;\n\n\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.utils.Helpers;\n\n@Data\n@AllArgsConstructor\n@Entity(name=\"BoardGame\")\n@Table(name=\"BOARDGAME_TABLE\")\n@JsonSerialize\npublic class BoardGame {\n\n    @Id\n    @GenericGenerator(name=\"system-uuid\", strategy=\"uuid\")\n    @Column(name=\"gameID\", updatable=false)\n    private String gameID;\n    @Column(name=\"gameTitle\")\n    private String gameTitle;\n    @Column(name=\"minPlayers\")\n    private int minPlayers;\n    @Column(name=\"maxPlayers\")\n    private int maxPlayers;\n    @Column(name=\"minPlayTime\")\n    private int minPlayTime;\n    @Column(name=\"maxPlayTime\")\n    private int maxPlayTime;\n\n    public BoardGame(String gameTitle){\n        this.gameID = Helpers.generateUUID();\n        this.gameTitle = gameTitle;\n        this.minPlayers = 0;\n        this.maxPlayers = 0;\n        this.minPlayTime = 0;\n        this.maxPlayTime = 0;\n    }\n    public BoardGame(String gameTitle, int minPlayers, int maxPlayers, int minPlayTime, int maxPlayTime){\n        this.gameID = Helpers.generateUUID();\n        this.gameTitle = gameTitle;\n        this.minPlayers = minPlayers;\n        this.maxPlayers = maxPlayers;\n        this.minPlayTime = minPlayTime;\n        this.maxPlayTime = maxPlayTime;\n    }\n\n    public BoardGame(){\n        this.gameID = Helpers.generateUUID();\n    }\n\n    @Override\n    @JsonValue\n    public String toString() {\n        return this.getGameTitle();\n    }\n}"
  },
  {
    "objectID": "backend/classes.html#gamestats",
    "href": "backend/classes.html#gamestats",
    "title": "Entities",
    "section": "",
    "text": "This class will be used to record statistics from the games played by the user. More features and developement will be done\npackage org.teamcifo.tindergames.gamesCollectionEntity;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.Objects;\n\n@Getter\n@Setter\n// JPA annotations\n@Entity(name = \"GameStats\")\n@Table(name = \"GAME_STATS\")\npublic class GameStats {\n    @Id\n    @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String gameStatsId;\n    private double buyPrice;\n    private int numTimesPlayed;\n    private int numWins;\n    private boolean owned;\n\n    public GameStats() {\n        this.gameStatsId = Helpers.generateUUID();\n        this.buyPrice = 0.0;\n        this.numTimesPlayed = 0;\n        this.numWins = 0;\n        this.owned = false;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder stats = new StringBuilder();\n\n        stats.append(\"Price when bought:\\t\").append(this.getBuyPrice());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Number of times played:\\t\").append(this.getNumTimesPlayed());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Number of wins:\\t\").append(this.getNumWins());\n        stats.append(System.getProperty(\"line.separator\"));\n        stats.append(\"Game owned:\\t\").append(this.isOwned());\n        stats.append(System.getProperty(\"line.separator\"));\n\n        return stats.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof GameStats gameStats)) return false;\n        return Double.compare(gameStats.buyPrice, buyPrice) == 0 && numTimesPlayed == gameStats.numTimesPlayed && numWins == gameStats.numWins && owned == gameStats.owned;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(buyPrice, numTimesPlayed, numWins, owned);\n    }\n}"
  },
  {
    "objectID": "backend/classes.html#gameplay",
    "href": "backend/classes.html#gameplay",
    "title": "Entities",
    "section": "",
    "text": "Gameplay is the class that will manage the plays that user’s can publish and record in our service.\nStill under developement\npackage org.teamcifo.tindergames.gamePlayEntity;\n\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.teamcifo.tindergames.boardGameEntity.BoardGame;\nimport org.teamcifo.tindergames.userEntity.User;\nimport org.teamcifo.tindergames.utils.Helpers;\n\nimport java.util.Set;\n\n// Lombok annotations\n@Getter\n@Setter\n// JPA annotations\n@Entity(name=\"GamePlay\")\n@Table(name=\"GAMEPLAY_TABLE\")\npublic class Gameplay {\n    @Id\n    @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\")\n    @Column(updatable = false, nullable = false)\n    private String gameplayId;\n    @ManyToOne\n    @JoinColumn(name = \"gameID\")\n    private BoardGame boardGame;\n    @Column\n    private Long time;\n    @ManyToOne\n    @JoinColumn(name = \"id\")\n    private User winner;\n\n    @ManyToMany\n    @JoinTable(name = \"USER_GAMEPLAY\",\n            joinColumns = @JoinColumn(name = \"GAMEPLAY_FK\"),\n            inverseJoinColumns = @JoinColumn(name = \"USER_FK\")\n    )\n    private Set&lt;User&gt; players;\n\n    public Gameplay() {\n        this.gameplayId = Helpers.generateUUID();\n    }\n}"
  },
  {
    "objectID": "frontend/mock-up.html",
    "href": "frontend/mock-up.html",
    "title": "Mock-up",
    "section": "",
    "text": "Introduction\n\n\n\n\n\n\nTODO: Pending to populate this entry"
  }
]